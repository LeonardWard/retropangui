#!/usr/bin/env bash
#
# 파일명: retroarch_utils.sh
# RetroArch 관련 유틸리티 함수
# ===============================================

create_runcommand_script() {
    local script_path="$USER_SYSTEM_PATH/runcommand.sh"
    log_msg INFO "runcommand.sh 스크립트를 생성합니다: $script_path"

    # heredoc의 EOF를 'EOF'로 감싸지 않았으므로, 내부 변수는 반드시 이스케이프(\$) 처리해야 합니다.
    sudo tee "$script_path" > /dev/null << 'EOF'
#!/usr/bin/env bash

# 파일명: runcommand.sh
# --- [1] 환경 설정 로드 ---
# runcommand.sh는 독립 실행을 위해 runcommand_config.sh에서 모든 경로 변수를 로드해야 합니다.
SOURCE_PATH="$(dirname "${BASH_SOURCE[0]}")/runcommand_config.sh"
source "$SOURCE_PATH" || {
    # 설정 파일 로드 실패 시, 최소한 /tmp에 오류를 기록하고 종료합니다.
    # 이 로그는 runcommand_config.sh 로드 전에 실행되므로, 경로 정의 오류를 잡아낼 수 있습니다.
    echo "$(date +'%Y-%m-%d %H:%M:%S') - 치명적 오류: 설정 파일 로드 실패. ($SOURCE_PATH) 파일을 찾을 수 없거나 권한 문제가 있습니다." > /tmp/runcommand_fatal.log
    exit 1
}
# --------------------------

# 인수 처리
SYSTEM_NAME="$3"
ROM_PATH="$4"

# 로그 파일 준비
# USER_LOGS_PATH는 runcommand_config.sh를 통해 로드됩니다.
RUN_LOG="$USER_LOGS_PATH/runcommand.log"

log() {
    # 로그 디렉토리가 존재하는지 확인하고 없으면 생성합니다. (쓰기 권한 문제 방지)
    mkdir -p "$(dirname "$RUN_LOG")" 2>/dev/null
    echo "$(date +'%Y-%m-%d %H:%M:%S') - $1" >> "$RUN_LOG"
}

log "--- Runcommand 시작 ---"
log "시스템: $SYSTEM_NAME"
log "롬 경로: $ROM_PATH"

EMULATORS_CFG_PATH="$USER_CONFIG_PATH/cores/$SYSTEM_NAME/emulators.cfg"
log "emulators.cfg 경로: $EMULATORS_CFG_PATH"

if [[ ! -f "$EMULATORS_CFG_PATH" ]]; then
    log "오류: emulators.cfg 파일을 찾을 수 없습니다."
    exit 1
fi

# 1. 기본 에뮬레이터 ID 추출
DEFAULT_EMU_ID=$(grep "^default\s*=" "$EMULATORS_CFG_PATH" | cut -d'=' -f2 | tr -d ' "')
log "기본 에뮬레이터 ID: $DEFAULT_EMU_ID"


if [[ -z "$DEFAULT_EMU_ID" ]]; then
    log "오류: emulators.cfg에 기본 에뮬레이터(default)가 설정되지 않았습니다."
    exit 1
fi

# 2. LAUNCH_COMMAND 추출 (sed로 = 뒤 "값"만 추출)
LAUNCH_COMMAND=$(grep "^$DEFAULT_EMU_ID\s*=" "$EMULATORS_CFG_PATH" | sed 's/^[^=]*= *\("[^"]*"\).*$/\1/' | sed 's/^"\(.*\)"$/\1/')
log "추출된 실행 명령어: $LAUNCH_COMMAND"

if [[ -z "$LAUNCH_COMMAND" ]]; then
    log "오류: 에뮬레이터 ID '$DEFAULT_EMU_ID'에 대한 실행 명령어를 찾을 수 없습니다."
    exit 1
fi

# 3. FINAL_COMMAND 생성 (롬 경로를 쌍따옴표로 감싸 치환)
# %ROM%을 "$ROM_PATH"로 치환하여 공백 포함 경로를 안전하게 처리
FINAL_COMMAND="${LAUNCH_COMMAND//\%ROM\%/\"$ROM_PATH\"}"
log "최종 실행 명령어: $FINAL_COMMAND"

# 4. 명령어 실행 (foreground로 실행하여 ES가 에뮬 종료 대기)
eval "$FINAL_COMMAND"

log "--- Runcommand 종료 ---"
EOF

    # 스크립트 소유자 및 실행 권한 설정
    sudo chown "$__user":"$__user" "$script_path"
    sudo chmod +x "$script_path"
    log_msg SUCCESS "runcommand.sh 생성 및 실행 권한 설정 완료."
}

# runcommand_config.sh 스크립트를 생성하는 함수
# 이 함수는 config.sh에서 이미 정의된 환경 변수들을 캡처하여 하드코딩된 설정 파일을 만듭니다.
create_runcommand_config_script() {
    local project_root="$1"
    # USER_SYSTEM_PATH는 config.sh에서 이미 설정되었으므로 바로 사용합니다.
    local script_path="$USER_SYSTEM_PATH/runcommand_config.sh"
    log_msg INFO "runcommand_config.sh 스크립트를 생성합니다: $script_path"

    # --- [1] 변수 사전 계산 제거: config.sh에서 설정된 환경 변수를 직접 사용합니다. ---
    # local effective_user="$(get_effective_user)"
    # ... 불필요한 재계산 로직 제거 ...
    # --------------------------------------------------------------------------------

    sudo tee "$script_path" > /dev/null << EOF
#!/usr/bin/env bash

# 파일명: runcommand_config.sh
# This file contains configuration variables specifically for runcommand.sh
# It is designed to provide hardcoded, persistent path variables.
# It is generated by create_runcommand_config_script() in func.sh using the variables
# exported by the main config.sh script during installation.

# --- [1] Project Root and Modules Directory (하드코딩 - 환경 변수 사용) ---
export RETROPANGUI_PROJECT_ROOT="${project_root}"
export RETROPANGUI_MODULES_DIR="${RETROPANGUI_PROJECT_ROOT}/scriptmodules"

# --- [2] 사용자 및 홈 디렉토리 설정 (하드코딩 - 환경 변수 사용) ---
export __user="${__user}"
export USER_HOME="${USER_HOME}"

# --- [3] 사용자별 경로 설정 (USER_HOME 기반 - 하드코딩 - 환경 변수 사용) ---
export USER_SHARE_PATH="${USER_SHARE_PATH}"
export USER_SYSTEM_PATH="${USER_SYSTEM_PATH}"
export USER_CONFIG_PATH="${USER_CONFIG_PATH}"
export USER_LOGS_PATH="${USER_LOGS_PATH}"
EOF

    sudo chown "$__user":"$__user" "$script_path"
    sudo chmod +x "$script_path"
    log_msg SUCCESS "runcommand_config.sh 생성 및 실행 권한 설정 완료."
}


# RetroArch 구성요소(에셋, 설정 등)를 Git에서 클론/설치하는 함수
# 사용법: install_ra_component "component_name" "git_url" "target_dir"
install_ra_component() {
    local component_name="$1"
    local git_url="$2"
    local target_dir="$3"
    local subdir="$(basename "$target_dir")"

    log_msg STEP "RetroArch $component_name 소스 클론 및 설치 시작..."

    if [[ -z "$git_url" || -z "$target_dir" ]]; then
        log_msg ERROR "$component_name 설치 실패: URL 또는 대상 디렉터리가 비어있습니다."
        return 1
    fi

    local ext_folder="$(get_Git_Project_Dir_Name "$git_url")"
    local build_dir="$INSTALL_BUILD_DIR/$ext_folder"
    log_msg INFO "ℹ️ $component_name 프로젝트 이름: $ext_folder"
    log_msg INFO "ℹ️ $component_name 빌드 디렉터리: $build_dir"

    log_msg INFO "$component_name 저장소($git_url) 클론 또는 pull 중..."
    git_Pull_Or_Clone "$git_url" "$build_dir" || return 1

    log_msg INFO "$component_name 빌드 및 설치 중 (대상: $target_dir)..."
    cd "$build_dir" || { log_msg ERROR "$component_name 설치 실패: 빌드 디렉터리로 이동할 수 없습니다."; return 1; }

    # If target_dir exists and is not empty, back it up
    if [ -d "$target_dir" ] && [ -n "$(ls -A "$target_dir")" ]; then
        sudo mv "$target_dir" "${target_dir}.backup_$(date +%Y%m%d_%H%M%S)"
    fi

    # Create target_dir if it doesn't exist
    sudo mkdir -p "$target_dir"

    log_msg INFO "$component_name: make install 실행 중 (대상: $target_dir)..."
    sudo make PREFIX="$USER_HOME" INSTALLDIR="$target_dir" install || {
        log_msg ERROR "$component_name 설치 실패 (make install 오류)."
        return 1
    }

    # 임시 설치 디렉터리 설정
    sudo chown -R "$__user":"$__user" "$target_dir"
    log_msg SUCCESS "RetroArch $component_name 설치 완료: $target_dir (/database/cht, /database/rdb 구조)"
    return 0
}
